[{"title":"对C语言宏定义的一些总结","url":"/2025/03/05/defineInC/","content":"符号常量与const常量符号常量通俗地讲就是“替换”，即用一个标识符来替代常量，又称为“宏定义”或者“宏替换”。其格式如下\n#define 标识符 常量\n\n例如下面这个例子是把圆周率pi设置为3.14，注意末尾不加分号\n#define pi 3.14\n\n于是在程序中凡是使用pi的地方将在程序执行前全部自动替换为3.14\n另一个定义常量的方法是使用const，其格式如下：\nconst 数据类型 变量名 = 常量;\n\n仍然用pi来举例：\nconst double pi = 3.14\n\n\n\ndefine的其他用法define除了可以定义常量外，其实可以定义任何语句或片段。其格式如下：\n#define 标识符 任何语句或片段\n\n例如可以写一个这样的宏定义：\n#define ADD(a, b) ((a) + (b))\n\n这样就可以直接使用ADD(a,b)来代替a + b的功能：\n#include &lt;stdio.h&gt;#define ADD(a, b) ((a) + (b))int main() &#123;    int num1 = 3, num2 = 5;    printf(&quot;%d&quot;, ADD(num1, num2));    return 0;&#125;\n\n输出结果：\n8\n\n宏定义的陷阱为什么要在上面加那么多括号呢？直接#define ADD(a, b) a + b不可以吗？或者，为保险起见，是否能写成#define ADD(a, b) (a + b)？实际上必须加那么多括号，这是因为宏定义是直接将对应的部分替换，然后才进行编译和运行。因此像下面这种程序，就会出问题：\n#include &lt;stdio.h&gt;#define CAL(x) (x * 2 + 1)int main() &#123;    int a = 1;    printf(&quot;%d\\n&quot;, CAL(a + 1));    return 0;&#125;\n\n输出结果：\n4\n\n这个结果跟我们预想的结果可能不太一致，许多人可能觉得应该是5才对。实际上这就是宏定义的陷阱，它把替换的部分直接原封不动替换进去，导致CAL(a + 1)实际是(a + 1 * 2 + 1)，也就是4，而不是((a + 1) * 2 + 1)\n","tags":["C","宏定义"]},{"title":"基于C++面向对象的多级反馈队列调度算法的模拟实现","url":"/2023/12/27/MLFQ/","content":"引言\n在多道程序系统中，进程的数量往往多于处理机的个数，因此进程争用处理机的情况在所难免。处理机调度是对处理机进行调度，即从就绪队列中按照一定的算法（公平、高效的原则）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。\n处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题\n\n处理机调度若没有处理机调度，意味着要等到当前运行的进程执行完毕后，下一个进程才能执行，而实际情况中，进程时常需要等待一些外部设备的输入，而外部设备的速度与处理机相比是非常缓慢的，若让处理机总是等待外部设备，则对处理机的资源是极大的浪费。而引进处理机调度后，可以在运行进程等待外部设备时，把处理机调度给其他进程，从而提高处理机的利用率。用一句简单的话来说，就是为了合理地处理计算机的软&#x2F;硬件资源\n调度算法出现了调度的概念后，又有了一个问题，即如何调度、应该满足谁、应该让谁等待，这是调度算法所回答的问题。常见的调度算法包括：\n\n先来先服务（FCFS）调度算法\n短作业优先（SJF）调度算法\n优先级调度算法\n高响应比优先（HRRN）调度算法\n时间片轮转（RR）调度算法\n多级反馈队列（MLFQ）调度算法\n\n其中，本文着重介绍的是多级反馈队列（MLFQ）调度算法\n算法概述\n多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展。通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。例如，为提高系统吞吐量和缩短平均周转事件而照顾短进程；为获得较好的I&#x2F;O设备利用率和缩短响应时间而照顾I&#x2F;O型进程；同时，也不必事先估计进程的执行时间\n\n实现思想多级反馈队列调度算法的实现思想如下：\n\n设置多个就绪队列，并为每个队列赋予不同的优先级。第1级队列的优先级最高，第2级队列的优先级次之，其余队列的优先级逐个降低\n赋予各个队列的进程运行时间片的大小各不相同。在优先级越高的队列中，每个进程的时间片就越小。例如，第i+1级队列的时间片要比第i级队列的时间片长1倍\n每个队列都采用FCFS算法。当新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。若它在一个时间片结束时尚未完成，调度程序将其转入第2级队列的末尾等待调度；若它在第2级队列中运行一个时间片后仍未完成，再将它放入第3级队列······，以此类推。当进程最后被降到第n级队列后，在第n级队列中便采用时间片轮转方式运行\n按队列优先级调度。仅当第1级队列为空时，才调度第2级队列中的进行运行；仅当第1~i-1级队列均为空时，才会调度第i级队列中的进程运行。若处理机正在执行第i级队列中的进程时，又有新进程进入任何一个优先级较高的队列，此时须立即把正在运行的进程放回到第i级队列的末尾，而把处理机分配给新到的高优先级进程\n\n算法特征\n对于终端型作业用户：短作业优先\n对于短批处理作业用户：周转时间较短\n对于长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理\n\n算法实现过程与思路\n以下实现的为一个包含三级队列，时间片长度依次为1、2、4的多级反馈队列，且只考虑每次执行整数个单位时间片的情况\n\n函数的功能要求是在根据给定的时间片，利用多级反馈队列调度算法对当前系统中存在的进程在给定的时间片内实现CPU时间的分配与进程调度\n因此一个比较简单的想法是给时间片分段，将整个过程划分为长度等于一个单位时间片的多个小过程，通过模拟时间每次行进一个单位时间片，我们可以轻易地得出每个单位时间片末各进程的各类信息以及各级队列当中所包含的进程情况\n多级反馈队列调度算法中的一个重要的思想是，仅当低于当前层级队列的所有队列同时全部为空队列时，才会调度当前层级队列中的进程运行。这意味着，在实现过程中，我们可以从低级队列往高级队列进行逐步考虑和实现。\n第1级队列先考虑第1级队列的实现，由于第1级队列每次能分配的最长时间片的长度为1，因此不需要将这个过程考虑得太过复杂，可以明确的是：\n\n一旦有新的进程创建成功，它就一定会立即插入到第1级队列的队尾\n由于每次能分配的最长时间片的单位长度为1，在本次给定的总时间片中，第1队列对进程的调度一定是连贯的，这里的连贯是指在经过任意长度的时间片的调度与分配后，第1级队列中所有与本次调度相关的进程，要么完成并撤离系统，要么插入到第2级队列的队尾，所有被分配过CPU时间的进程都将立即从第1级队列中弹出，而不会出现在经过调度运行后当前进程未完成，同时本次运行中当前进程被一次性分配的时间片长度未达到发生队列调度的时间片长度，导致当前进程继续驻留在第1级队列当中等待下一次用户输入时间片来进一步判断进程的调度情况\n\n认识到了这两点，在实现第1级队列时只需要考虑两种情况，只要第1级队列不空，就能不断地分配单位时间片并调度，同时在本次运行中，被分配过单位时间片后的进程要么转为完成态并从系统中撤离，要么被插入到第2级队列的队尾，无论如何，此进程都将立即从第1级队列中弹出\n第2级队列然后考虑第2级队列的实现，第2级队列每次能分配的最长时间片的长度为2，这意味着相比于第1级队列，在本次用户给定的时间片末，可能会出现第2级队列的队首进程仍然滞留在第2级队列的队首，因为我们不知道下一次系统运行时是否仍需继续运行该进程。因此，这里我们需要引入一个额外的变量来解决这个复杂的情况，这个变量需要记录进程单次连续上处理机运行的时间，这里的连续指的是本次运行中没有发生因进程调度导致的运行中断。这样，无论用户将整个系统运行过程分成多少段运行，系统都能正确地进行进程调度。需要注意的是，由于连续运行时间记录的是进程上处理机运行中没有发生进程调度导致中断的时间，因此，一旦整个系统中产生了由较高级队列进程到较低级队列进程的处理机调度，那么较高级队列中的队首进程的连续运行时间必须清0，这意味着他们本次运行过程的终止\n第3级队列最后是考虑第3级队列的实现，第3级队列每次能分配的最长时间片的长度为4，这意味着第3级队列所面临的情况与第2级队列一样，可以通过照搬第2级队列的处理方法来解决第3级队列的问题，只不过，与第2级队列不同的，由于第3级队列是最高级的队列，单次分配完4单位长度的时间片后，进程并不会进入到更高一级的队列，而是重新被插入到第3级队列的队尾，因此，我们只需要对第2级队列的处理方式进行简单的修改，便能将其运用到第3级队列上。\n代码实现\n这里只粘贴重要函数的代码，完整代码请移步OS多级反馈队列调度算法 (github.com)\n\n// 采用多级反馈队列调度算法运行若干时间片void Run(int time) &#123;    // 模拟时间流逝    for (int i = 0; i != time;) &#123;        // 只要第1队队列不空，就持续对第1队队列中的进程调度并分配时间片        if (!firstQueue.empty()) &#123;            // 此时已经进入第1队队列中，如果第2、3队队列不空，说明上次时间片分配给的是第2、3队队列的进程，此时需要将处于第2、3队队列中的进程的持续运行记录清0            if (!secondQueue.empty()) &#123;                if (secondQueue.front().getContinuation() != 0) &#123;                    Process *process = &amp;(secondQueue.front()); // 获取第2级队列队头进程                    process-&gt;getPCB()-&gt;setStatus(&#x27;W&#x27;); // 发生调度后变为等待态                    process-&gt;setContinuation(0); // 连续运行时间清0                    secondQueue.pop();                    secondQueue.push(*process); // 这一行和上一行的顺序不能调换，他们操作的是同一个process对象                &#125;            &#125;            if (!thirdQueue.empty()) &#123;                if (thirdQueue.front().getContinuation() != 0) &#123;                    Process *process = &amp;(thirdQueue.front()); // 获取第3级队列队头进程                    process-&gt;getPCB()-&gt;setStatus(&#x27;W&#x27;); // 发生调度后变为等待态                    process-&gt;setContinuation(0); // 连续运行时间清0                    thirdQueue.pop();                    thirdQueue.push(*process); // 这一行和上一行的顺序不能调换，他们操作的是同一个process对象                &#125;            &#125;            nowTime++; // 当前时间增加            i++; // 模拟分配了时间片=1的CPU时间            Process &amp;process = firstQueue.front(); // 获取第1队队列首进程            PCB *pcb = process.getPCB(); // 获取该进程的PCB            pcb-&gt;setStatus(&#x27;R&#x27;); // 进程上处理机运行转为运行态            pcb-&gt;setUsedTime(pcb-&gt;getUsedTime() + 1); // 已用CPU时间+1            process.setContinuation(process.getContinuation() + 1); // 连续运行时间+1            // 如果运行完成            if (pcb-&gt;getUsedTime() == pcb-&gt;getTotalTime()) &#123;                firstQueue.pop(); // 弹出第1队队列                pcb-&gt;setStatus(&#x27;F&#x27;); // 状态设置为完成态            &#125; else &#123;                // 由于第一队队列的时间片为1，因此不用考虑已占用CPU时间大于需要运行时间的情况，此时考虑该进程未完成的情况                pcb-&gt;setStatus(&#x27;W&#x27;); // 发生进程调度变为等待态                process.setContinuation(0); // 发生调度，需要将进程的持续运行记录清0                secondQueue.push(process); // 放入第2队队列的队尾                firstQueue.pop(); // 弹出第1队队列            &#125;        &#125; else if (!secondQueue.empty()) &#123;            // 同上，此时已经进入第2队队列中，如果第3队队列不空，此时需要将处于第3队队列中的进程的持续运行记录清0            if (!thirdQueue.empty()) &#123;                if (thirdQueue.front().getContinuation() != 0) &#123;                    Process *process = &amp;(thirdQueue.front()); // 获取第3级队列队首进程                    process-&gt;getPCB()-&gt;setStatus(&#x27;W&#x27;); // 获取该进程的PCB                    process-&gt;setContinuation(0); // 连续运行时间清0                    thirdQueue.pop();                    thirdQueue.push(*process); // 这一行和上一行的顺序不能调换，他们操作的是同一个process对象                &#125;            &#125;            Process *process = &amp;(secondQueue.front()); // 获取第2队队列的队首进程            PCB *pcb = (*process).getPCB(); // 该进程的PCB            // 只要第2队队列不为空且本次分配的CPU时间片未使用完，就不断对处于第2队队列中的进程进行调度和分配时间片            while (!secondQueue.empty() &amp;&amp; i != time) &#123;                i++; // 模拟分配了时间片=1的CPU时间                nowTime++; // 当前时间增加                pcb-&gt;setStatus(&#x27;R&#x27;); // 将状态设置为运行态                pcb-&gt;setUsedTime(pcb-&gt;getUsedTime() + 1); // 当前进程已占用CPU时间增加                process-&gt;setContinuation(process-&gt;getContinuation() + 1); // 当前进程连续运行时间的记录增加                // 若进程完成                if (pcb-&gt;getUsedTime() == pcb-&gt;getTotalTime()) &#123;                    pcb-&gt;setStatus(&#x27;F&#x27;); // 将状态设置为完成态                    secondQueue.pop(); // 从第2队队列中弹出该进程                    process = &amp;(secondQueue.front()); // 切换下一个进程                    pcb = process-&gt;getPCB(); // 获取该进程PCB                    continue; // 跳过后续处理                &#125;                // 若达到第2队队列所能分配的最大时间片                if (process-&gt;getContinuation() == secondQueueTime) &#123;                    pcb-&gt;setStatus(&#x27;W&#x27;); // 发生进程调度状态变为等待态                    process-&gt;setContinuation(0); // 发生进程调度，进程连续运行时间记录清0                    thirdQueue.push(*process); // 将该进程放入第3队队列                    secondQueue.pop(); // 将该进程从第2队队列中弹出                    process = &amp;(secondQueue.front()); // 切换下一个进程                    pcb = process-&gt;getPCB(); // 获取该进程的PCB                &#125;            &#125;        &#125; else &#123;            // 当其他队列为空时便对第3队队列中的进程进行调度并分配时间片            Process *process = &amp;(thirdQueue.front()); // 获取第3队队列队首的进程            PCB *pcb = (*process).getPCB(); // 获得该进程的PCB            // 当程序进入到处理第三队队列的进程调度时，这意味着前两个队列都是空的，由于第3队队列是最高级的队列，进程在这将采用时间片轮转的调度算法            while (!thirdQueue.empty() &amp;&amp; i != time) &#123;                i++;                nowTime++;                pcb-&gt;setStatus(&#x27;R&#x27;); // 状态变为运行态                pcb-&gt;setUsedTime(pcb-&gt;getUsedTime() + 1); // 当前进程已占用CPU时间增加                process-&gt;setContinuation(process-&gt;getContinuation() + 1); // 当前进程连续运行时间的记录增加                // 若进程完成                if (pcb-&gt;getUsedTime() == pcb-&gt;getTotalTime()) &#123;                    pcb-&gt;setStatus(&#x27;F&#x27;); // 将状态设置为完成态                    thirdQueue.pop(); // 从第3级队列中弹出该进程                    process = &amp;(thirdQueue.front()); // 切换下一个进程                    pcb = process-&gt;getPCB();// 获取该进程的PCB                    continue; // 跳过后续处理                &#125;                // 若达到第3级队列所能分配的最大时间片                if (process-&gt;getContinuation() == thirdQueueTime) &#123;                    pcb-&gt;setStatus(&#x27;W&#x27;); // 发生进程调度状态变为等待态                    process-&gt;setContinuation(0); // 连续运行时间清0                    thirdQueue.pop();                    thirdQueue.push(*process); // 这一行和上一行顺序不能调换，他们操作的是同一个process对象                    process = &amp;(thirdQueue.front()); // 切换下一个进程                    pcb = process-&gt;getPCB(); // 获取该进程的PCB                &#125;            &#125;            // 所有进程运行完成            if (thirdQueue.empty()) &#123;                nowTime += time - i;                i = time; // 直接结束            &#125;        &#125;    &#125;    processTable.display(); // 打印进程信息    menu(); // 返回菜单&#125;\n\n遇到的问题\n这部分用于记录我在具体实现过程中遇到的问题\n\n问题描述采用面向对象的实现方式时，在调用了对象的成员方法对成员变量进行操作时，同时是使用getter和setter成员方法，对于一部分对象来说，他们的getter和setter能正常地获取和修改对象的成员变量，但对于另一部分对象来说，他们的getter和setter是毫无作用的\n问题分析程序中存在三个重要的对象：进程控制块（PCB）、进程（Process）、系统进程表（ProcessTable），他们之间存在着很强的关联关系：一个进程对应一个进程控制块，这意味着Process类中会有一个PCB类型的成员变量；系统进程表中包含多个进程，这意味着ProcessTable类中有一个向量vector&lt;Process&gt; processes用来存储系统中的多个进程。在操作上述的这些相关联的对象时，就必须注意深拷贝和浅拷贝的问题，这意味着你不能将getter返回的值赋值到另一个相同类型的变量上，一旦这么做，这个变量只是原本需要操作的对象的一个副本，对该变量的所有操作都不会对原对象产生影响\n问题解决我一共采用了两种方法针对关联对象的深拷贝和浅拷贝问题\n\n直接改变成员变量的类型，将其改为原类型的指针，这一方法的具体实施体现在了Process类中，我将原本PCB类型成员变量改为了PCB*类型，这样，通过getter返回的指针即使被赋值到另一共变量上后依然能精准地指向原对象\n将getter的返回值设置为引用类型，同时，在具体的代码实现中通过&amp;获取返回值的地址，这样我们便又一次得到了我们需要操作的对象的指针，无论如何赋值，这个指针始终指向我们需要操作的对象\n\n总结不难看出这其实是一个操作系统的课程设计的内容，不可否认的是，这个课程设计极大地引起了我的兴趣以至于我愿意为了它写一篇这样的博客。多级反馈队列调度算法——作为操作系统这门课中的一种相对复杂的算法，它的实现毫无疑问充满了挑战，但当真正去将它付以实践时，我被其设计的巧妙之处所折服，或许，这就是算法设计的魅力\n","tags":["MLFQ","C++","模拟","面向对象","算法"]},{"title":"初识Playwright","url":"/2023/11/21/playwright/","content":"Playwright概述Playwright是一个由Microsoft开发的开源自动化测试工具，专为满足端到端需求而创建，Playwright的API覆盖了所有现代浏览器，包括谷歌Chrome和微软Edge（Chrome内核）、苹果Safari（WebKit内核）和Mozilla Firefox，可在 Windows、Linux 和 macOS 上进行本地测试或在 CI 上进行测试，也可使用本地移动模拟进行无头测试或有头测试。\n因为其弹性的页面元素选择器，Playwright可以依靠面向用户的字符串，如文本内容和label标签来选择元素，通过录制和回放用户操作，Playwright可以实现对网页的自动化操作，如点击、输入等，从而更准确地模拟真实用户的使用场景\nPlaywright安装\n这里只介绍基于Python的Playwright安装\n\nPip安装pip install --upgrade pippip install playwrightplaywright install\n\n\npip install --upgrade pip：这个命令的目的是升级Python包管理工具pip本身\n\npip install playwright：这个命令用于通过pip安装Playwright Python库\n\nplaywright install：这个命令是Playwright的命令行工具，用于安装或更新浏览器\n\n\nConda安装conda config --add channels conda-forgeconda config --add channels microsoftconda install playwrightplaywright install\n\n\nconda config --add channels conda-forge：这个命令向Conda配置中添加了一个新的软件包通道（channel），即conda-forge\nconda config --add channels microsoft：这个命令向Conda配置中添加了另一个软件包通道，即microsoft\nconda install playwright：这个命令使用Conda来安装Playwright库\n\nPlaywright常用工具\nPlaywright脚本使用现有的调试工具，如Python调试器和浏览器开发者工具。除此之外，Playwright还未浏览器自动化引入了新的调试功能\n\nTest Generator（测试生成器）\nPlaywright Test Generator是一个GUI工具，它帮助你了解测试中记录的Playwright的运行过程，这意味着你可以查看测试中的每一个操作，并直观的看到每个操作期间都发生了什么\n\nplaywright codegen &lt;url&gt;\n\n\n\nInspector（检查器）\nPlaywright Inspector是一个GUI工具，帮助编写和调试Playwright脚本，这也是默认推荐的脚本debug工具\n\n\n设置环境变量（powerShell）\n\n$env:PWDEBUG=1\n\n\n运行测试脚本（debug模式）\n\npytest -s &lt;被测试的Python文件名&gt;\n\n\n还原环境变量（powerShell）\n\n$env:PWDEBUG=&quot;console&quot;\n\n\n\nTrace Viewer（跟踪查看器）\nPlaywright Trace Viewer是一个GUI工具，用于帮助记录脚本运行时的产生的详细堆栈信息\n\n\n实例代码\n\nbrowser = chromium.launch()context = browser.new_context()# Start tracing before creating / navigating a page.context.tracing.start(screenshots=True, snapshots=True, sources=True)page = context.new_page()page.goto(&quot;https://playwright.dev&quot;)# Stop tracing and export it into a zip archive.context.tracing.stop(path = &quot;trace.zip&quot;)\n\n执行该Python脚本文件后，会在脚本所在目录生成一个trace.zip文件\n\n本地打开\n\nplaywright show-trace trace.zip\n\n简单的网络爬虫前一节我们介绍了较为实用的三个Playwright的内置工具，得益于Playwright的强大功能和较低的门槛，通过使用这些工具，我们能轻松的完成一些简单的网络爬虫的编写\n\n以下是一个从某高考志愿分析网站获取各个大学信息的网络爬虫的例子\n\n在终端使用codegen命令，此时Test Generator运行，打开了一个新的浏览器的空白页，我们输入网址，进入到该网站的院校库，之后我们关闭这个浏览器，Test Generator为我们生成了这样一段Python代码：\nfrom playwright.sync_api import Playwright, sync_playwright, expectdef run(playwright: Playwright) -&gt; None:    browser = playwright.chromium.launch(headless=False)    context = browser.new_context()    page = context.new_page()    page.goto(&quot;https://m.youzy.cn/&quot;)    page.get_by_role(&quot;link&quot;, name=&quot;找大学&quot;).click()    page.frame_locator(&quot;iframe&quot;).get_by_text(&quot;大学排名&quot;).click()    page.frame_locator(&quot;iframe&quot;).get_by_role(&quot;feed&quot;).locator(&quot;div&quot;).filter(has_text=&quot;清华大学 985 211 国重点 保研 双一流 北京 海淀区 / 综合 / 公办 / 排名:1&quot;).first.click()    page.close()    # ---------------------    context.close()    browser.close()with sync_playwright() as playwright:    run(playwright)\n\n可以看到脚本文件中已经得到了一个用于记录清华大学信息的页面，我们只需使用适当的解析器进行解析，便能获取到其中包含的信息。此外，类比生成的代码，我们可以通过添加循环的方式获取到更多大学的页面以获取更多的数据，至此，我们便完成了一个简单的网络爬虫\n总结在这里，我们仅仅是简单地了解了Playwright的一些基本功能和作用，如同冰山一角，作为一项新兴的自动化测试工具，Playwright的生态和文档尚未达到完备，其许多强大的功能仍然等待着我们进一步的发掘\n","tags":["Python","Playwright","网络爬虫"]},{"title":"我的第一篇博客","url":"/2023/11/10/my-first-blog/","content":"Hexo博客的搭建\nHexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页\n\n超快速度\n\nNode.js所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染\n\n支持Markdown\n\nHexo支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件\n\n一键部署\n\n只需一条指令即可部署到 GitHub Pages, Heroku 或其他平台\n\n插件和可拓展性\n\n强大的 API 带来无限的可能，与数种模板引擎（EJS，Pug，Nunjucks）和工具（Babel，PostCSS，Less&#x2F;Sass）轻易集成\n\n原因为什么突然想到搭建个人的博客？大概是终于想主动做些有意思的事。可以预料到的是，这个博客大部分时间只有我自己会来浏览，偶尔或许会有人出于好奇，通过github上这个项目旁边的链接进来瞧瞧，不过这都无所谓了，姑且当它是我的一本日记，我想在这当中记录一些我想要记录的东西\n博客初成形相比于查阅官方文档，我更倾向于观看演示视频来解决问题，因为这样更便于我的操作与理解，一定程度上也减少了错误的发生。最初的默认主题博客搭建参考于b站上的up主CodeSheep的视频—手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo。\n一、环境准备\n安装Hexo前需先安装下列应用程序：\n\nNode.js\nGit\n\n\n1、安装Node.jsHexo是一个基于Node.js的博客框架，这意味着，想要搭建Hexo博客，我们需要先安装Node.js\n需要注意的是，官方文档中要求Node.js版本需不低于10.13，建议使用Node.js 12.0及以上版本。如果你的电脑中尚未安装Node.js，那么可以前往Node.js (nodejs.org)下载相应的安装包进行安装\n如果你像我一样，电脑中已经安装了Node.js，但需要升级到更高的版本，那么无需卸载原来的版本，Node.js提供了一种更加简单且高效的升级办法：下载所需版本的安装包，安装时选择当前版本的安装目录（此时的默认安装目录正常情况下便是当前版本的安装目录）安装即可，安装程序会将当前版本替换为需要安装的版本\n2、安装GitGit ，一个软件开发者必备的代码版本控制系统。Hexo 使用 Git 来管理主题和插件等外部依赖，并且在部署 Hexo 网站到远程仓库（如 GitHub、GitLab 等）时，Git 也是必需的。\n你可以前往Git (git-scm.com)进行下载\n如果你需要对你的git版本进行更新，你可以打开终端界面输入\ngit update-git-for-windows\n\n系统会为将你的git更新至最新的版本\n二、安装Hexo所有必备的应用程序安装完成后，即可使用npm安装Hexo\n1、全局安装：直接打开终端界面输入\nnpm install -g hexo-cli\n\n此时安装的Hexo可以在系统的任意一个目录下使用，你可以打开终端界面在任意一个目录下键入Hexo命令来搭建Hexo博客\n2、局部安装：进入需要安装的目录输入\nnpm install hexo\n\n此时安装的Hexo仅能在该目录及其子目录下使用，通过cmd命令框键入Hexo命令在该目录或其子目录下搭建Hexo博客\n3、旧版本Hexo安装考虑到并非所有人都愿意使用较新版本的Node.js，如果你坚持使用较旧版本的Node.js，你也可以安装旧版本的Hexo来避免版本不兼容的问题\n打开终端界面，然后运行以下命令，将version替换为你想要安装的Hexo版本号\nnpm install -g hexo@version\n\n例如，如果你想要安装Hexo的3.2.0版本，命令将如下所示\nnpm install -g hexo@3.2.0\n\n安装完成后，可以运行以下命令来检验Hexo的安装版本：\nhexo -v\n\n这将显示安装的Hexo版本号，以确保安装成功\n以下为Hexo与Node.js的版本对应表：\n\n\n\nHexo版本\n最低版本（Node.js版本）\n最高版本（Node.js版本）\n\n\n\n7.0+\n14.00\nlatest\n\n\n6.2+\n12.13.0\nlatest\n\n\n6.0+\n12.13.0\n18.5.0\n\n\n5.0+\n10.13.0\n12.0.0\n\n\n4.1 - 4.2\n8.10\n10.0.0\n\n\n4.0\n8.6\n8.10.0\n\n\n3.3 - 3.9\n6.9\n8.0.0\n\n\n3.2 - 3.3\n0.12\n未知\n\n\n3.0 - 3.1\n0.10或iojs\n未知\n\n\n0.0.1 - 2.8\n0.10\n未知\n\n\n你可以选择你当前Node.js版本所能支持的Hexo版本进行安装\n三、建立博客1、初始化经过上述准备后，系统已经满足了建立一个Hexo实例所需的所有条件\n执行下列命令\nhexo init &lt;folder&gt;cd &lt;folder&gt;npm install\n\n这里的&lt;folder&gt;是Hexo实例所处的文件夹，若当前目录下无该文件夹，系统会新建一个文件夹，在该文件夹的目录下，系统会生成一系列的文件，这里只介绍三个较为重要的文件\nsource\n初始情况下只有一个文件夹_posts（用于存放你博客正文的Markdown文件），后续可能需要添加其他文件夹，如about（用于存放about页面的Markdown文件），以及一个用于存放图片资源的文件夹images\nthemes\n这个文件夹初始情况下为空，它用于存放后续个性化博客时的主题文件\n_config.yml\n极其重要的文件，作为整个博客的配置文件，用于配置博客中的各类功能与内容\n2、本地运行执行以下命令\nhexo generate\n\nHexo会生成静态文件，这些文件就是博客的源码，他们被放到了public文件夹当中\n再执行\nhexo server\n\nHexo会启动本地服务器，并将生成的静态文件部署在该服务器上。默认情况下，访问网址为：http://localhost:4000/，你可以在浏览器的地址栏输入该网址进行访问\n你将看到\n\n这便是默认的Hexo博客，同时Hexo为你自动生成了一片示例文章，至此，我们完成了基本的Hexo博客的搭建\n部署\nGitHub提供了一项免费的静态站点托管服务GitHub Pages，它直接从GitHub上的仓库获取HTML、CSS和JavaScript文件，通过构建过程运行文件，然后发布网站\n\n要想使用GitHub Pages，首先我们需要创建一个用来管理Hexo生成的静态页面的仓库，GitHub Pages规定了这个仓库的命名格式应为&lt;你的GitHub用户名&gt;.github.io，同时这个仓库名后续也将成为公网访问该页面的地址 \n这里我们需要安装一个Hexo的上传插件deployer-git\nnpm install hexo-deployer-git --save\n\n后续这个插件将极大地便捷我们的推送\n然后我们需要进行推送信息的设置，使用vim打开配置文件_config.yml\nvim _config.yml\n\n找到deploy并将其修改为\ndeploy:  type: git  repo:https://github.com/&lt;你的GitHub用户名&gt;/&lt;你的GitHub用户名&gt;.github.io.git  branch: master\n\n在这之后，我们只需执行\nhexo deploy\n\n即可通过deployer-git快速的将本地的Hexo博客部署到GitHub Pages上，在首次推送时，需要进行GitHub的身份认证，输入用户名和密码后，系统将开始推送，完成推送后，查看对应的GitHub的仓库\n\n对应的静态页面文件已被推送到仓库中\n此时我们在浏览器的地址栏输入&lt;你的GitHub用户名&gt;.github.io便能访问该博客页面\n更换主题作为最热门的博客框架之一，Hexo拥有一大批第三方主题供用户选择。更换Hexo主题非常容易，找到你所需主题所对应的仓库并执行\ngit clone https://github.com/&lt;作者名&gt;/&lt;仓库名&gt;.git themes/&lt;主题名&gt;\n\ngit会将主题文件下载到themes中，之后再修改_config.yml中的theme\ntheme: &lt;主题名&gt;\n\n这样我们便完成了主题的更换\n以keep主题为例，首先我们将keep主题的文件克隆到themes中并命名为keep\ngit clone https://github.com/XPoet/hexo-theme-keep.git themes/keep\n\n然后修改配置文件中的theme\ntheme: keep\n\n至此，我们便将Hexo的主题换成了keep\n通常，一个主题可能会有以下的结构：\n.├── _config.yml├── languages├── layout├── scripts└── source\n\n_config.yml\n主题的配置文件。和 Hexo 配置文件不同，主题配置文件修改时会自动更新，无需重启 Hexo Server。\nlanguages\n语言文件夹\nlayout\n布局文件夹。用来存放主题的模板文件，决定了网站内容的呈现方式\nscripts\n脚本文件夹。在启动时，Hexo会加载此文件夹内的JavaScript文件\nsource\n资源文件夹，除了模板以外的Asset，例如CSS、JavaScript文件等，都应该放在这个文件夹中。文件或文件夹开头名称为_（下划线）或隐藏的文件会被忽略\n遇到的问题问题描述：最初更换主题时，出现了一个无法解释的现象，在本地运行时，主题的样式正常显示，但是当推送到GitHub Pages之后，无法在网页正常显示主题的样式，查看生成的对应静态文件，当中也无法找到明显的错误\n问题解决：打开_config.yml，发现当中存在这样一行\n# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: \n\n将其改成\n# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://&lt;仓库名&gt;\n\n问题完美解决\n问题分析：推测为，若在_config.yml文件中不设置或者不更改url的值，Hexo将使用默认值，这个默认值是一个相对路径，通常是”&#x2F;“，这就导致了资源文件的链接问题：如果你在Hexo中包含了任何链接，它们将使用默认的相对路径，这可能导致在部署到不同环境时生成的链接可能会指向错误的位置，进而导致大量资源无法加载\n总结虽然搭建Hexo并没有使我得到大量技术相关的收获，我收获的仅仅是一个简单的个人博客以及对于GitHub Pages的简单了解，但是通过一次这样的实践，更多的，我得到是精神层面的反馈，对于未知事物的认知与接触又一次触发了我对这个领域探索的热情。\n愿这份热忱，永不泯灭\n","tags":["Hexo","GitHub Pages","Node.js"]},{"title":"Hello World","url":"/2023/11/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]